@* @inherits AppCode.Razor.AppRazor
@using AppCode.Data *@
@* @using AppCode.Helpers *@

@inherits ToSic.Sxc.Dnn.RazorComponent
@using ToSic.Razor.Blade

@using System.Web;
@using System;

@{
  @* var cacheSettings = As<CacheSettings>(MyItem); *@
  var cacheSettings = Content;

  var isEnabled = cacheSettings.Get("IsEnabled") != null ? cacheSettings.IsEnabled : App.Settings.IsEnabled;
  var cacheMaxAge = cacheSettings.Get("MaxAge") != null ? cacheSettings.MaxAge : App.Settings.MaxAge;
  var cacheSMaxAge = cacheSettings.Get("SMaxAge") != null ? cacheSettings.SMaxAge : App.Settings.SMaxAge;
  var now = DateTime.UtcNow;
  var header = "";

  if (isEnabled)
  {
    @* HeaderCache.SetPublicCacheHeaders(Response, cacheMaxAge, cacheSMaxAge); *@
    SetPublicCacheHeaders(Response, (int)cacheMaxAge, (int)cacheSMaxAge);
    header = $"public, max-age={cacheMaxAge}, s-maxage={cacheSMaxAge}";
  }
}

@* <div class="accordion" id="app-cdn" @Kit.Toolbar.Default(MyItem)> *@
<div class="accordion" id="app-cdn" @Edit.TagToolbar(Content)>
  <div class="accordion-item">
    <h2 class="accordion-header">
      <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#app-cache-settings">
        Cache Settings @(isEnabled ? "✔️" : "❌")
      </button>
    </h2>
    <div id="app-cache-settings" class="accordion-collapse collapse show" data-bs-parent="#app-cdn">
      <div class="accordion-body">
        @* @if (MyUser.IsContentAdmin) *@
        @if (Edit.Enabled)
        {
          <h3>Flush Cache</h3>
          <div class="input-group mb-3">
            <button class="btn btn-primary" type="button" id="full-purge">Purge Everything</button>
            <button class="btn btn-outline-primary" type="button" id="custom-purge">Custom Purge</button>
            <input type="text" class="form-control" placeholder="Enter url which should be purged" value="@Link.To()" id="custom-purge-url">
          </div>
        }

        <h3>Stats:</h3>
        <ul>
          @* TODO: SHOW Cache-Control Header if not public *@
          <li><b>Cache Control should be:</b> @(isEnabled? header : "❌")</li>
          <li><b>Server-Zeit (UTC):</b> <span id="server-time">@now.ToString("yyyy-MM-dd HH:mm:ss")</span></li>
          <li><b>Browser-Zeit (lokal):</b> <span id="browser-time"></span></li>
          <li><b>CF-Cache-Status (HTML):</b> <span id="cf-status-html">wird geladen...</span></li>
          <li><b>CF-Cache-Status (JS):</b> <span id="cf-status-js">wird geladen...</span></li>
          <li><b>CF-Cache-Status (CSS):</b> <span id="cf-status-css">wird geladen...</span></li>
          <li><b>CF-Cache-Status (Bild):</b> <span id="cf-status-img">wird geladen...</span></li>
        </ul>
      </div>
    </div>
  </div>
</div>

@* <script src="@App.Folder.Url/dist/main.js"></script> *@
@* <script src="@App.Path/dist/main.js"></script> *@

<script>
  function updateBrowserTime() {
    const now = new Date();
    document.getElementById("browser-time").textContent =
      now.toLocaleString("de-DE", { hour12: false });
  }
  setInterval(updateBrowserTime, 1000);
  updateBrowserTime();

  async function getCacheStatus(url) {
    try {
      const res = await fetch(url, { method: "GET", cache: "reload" });
      const cf = res.headers.get("cf-cache-status") || "nicht vorhanden";
      const cc = res.headers.get("cache-control") || "nicht vorhanden";
      const isPublic = cc.toLowerCase().includes("public");
      return { cf, cc, isPublic };
    } catch {
      return { cf: "Fehler beim Laden", cc: "Fehler beim Laden", isPublic: false };
    }
  }

  function applyStatus(targetId, status) {
    const el = document.getElementById(targetId);
    if (!el) return;

    const colors = {
      HIT: "green",
      MISS: "orange",
      EXPIRED: "orange",
      DYNAMIC: "red",
      BYPASS: "red",
      "Fehler beim Laden": "red",
    };

    el.textContent = status;
    el.style.color = colors[status] || "black";
  }

  async function doTests(debug = false) {
    const targets = [
      { selector: window.location.href, prop: null, id: "cf-status-html" },
      { selector: "script[src]", prop: "src", id: "cf-status-js" },
      { selector: 'link[rel="stylesheet"][href]', prop: "href", id: "cf-status-css" },
      { selector: "img[src]", prop: "src", id: "cf-status-img" },
    ];

    const results = await Promise.all(
      targets.map(async ({ selector, prop }) => {
        if (prop === null) return getCacheStatus(selector);
        const el = document.querySelector(selector);
        return el ? getCacheStatus(el[prop]) : "nicht vorhanden";
      })
    );

    if (debug) {
      alert(
        `Cache Status:\n` +
        `HTML: CF=${results[0].cf}, CC=${results[0].cc}, ${results[0].isPublic ? "✅ public" : "❌ not public"}\n` +
        `JS:   CF=${results[1].cf}, CC=${results[1].cc}, ${results[1].isPublic ? "✅ public" : "❌ not public"}\n` +
        `CSS:  CF=${results[2].cf}, CC=${results[2].cc}, ${results[2].isPublic ? "✅ public" : "❌ not public"}\n` +
        `IMG:  CF=${results[3].cf}, CC=${results[3].cc}, ${results[3].isPublic ? "✅ public" : "❌ not public"}`
      );
    } else {
      for (let i = 0; i < targets.length; i++) {
        const el = document.getElementById(targets[i].id);
        if (!el) continue;

        applyStatus(targets[i].id, results[i].cf);

        const ccNote = results[i].isPublic ? "✅ public" : "❌ not public";
        el.insertAdjacentHTML("afterend", ` <small>(${ccNote})</small>`);
      }
    }
  }

  const debug = window.location.hash === "#debug";
  doTests(debug);
</script>

<script>
  const customPurgeBtn = document.querySelector('#custom-purge');
  if (customPurgeBtn) {
    customPurgeBtn.addEventListener('click', function () {
      const customUrl = document.querySelector('#custom-purge-url').value;
      purgeCache(customUrl);
    });
  }

  const fullPurgeBtn = document.querySelector('#full-purge');
  if (fullPurgeBtn) {
    fullPurgeBtn.addEventListener('click', function () {
      purgeCache();
    });
  }

  function purgeCache(url = '') {
    var sxc = $2sxc(6923);
    var urlParams = {};
    var postParams = {
      flushUrl: url
    };

    sxc.webApi.post('app/auto/api/Cache/Purge', urlParams, postParams)
      .then(data => {
        console.log(data)
      });
  }

</script>

@functions {
  public void SetPublicCacheHeaders(HttpResponseBase Response, int browserCacheSeconds, int cloudflareCacheSeconds)
  {
    Response.Cache.SetCacheability(HttpCacheability.Public);
    var ttlBrowser = TimeSpan.FromSeconds(browserCacheSeconds);
    var ttlCloudflare = TimeSpan.FromSeconds(cloudflareCacheSeconds);
    Response.Cache.SetMaxAge(ttlBrowser);
    Response.Cache.SetProxyMaxAge(ttlCloudflare);
  }
}