@* @inherits AppCode.Razor.AppRazor
@using AppCode.Data *@
@* @using AppCode.Helpers *@

@inherits ToSic.Sxc.Dnn.RazorComponent
@using ToSic.Razor.Blade

@using System.Web
@using System
@using DotNetNuke.Entities.Portals

@{
  // Get the current tab
  var currentTab = PortalSettings.Current;

  // Get all cache settings items as a list
  // var allCacheSettings = App.Data.GetAll<CacheSettings>();
  var allCacheSettings = AsList(App.Data["CacheSettings"]);

  var tab = currentTab.ActiveTab;
  var currentTabId = Dnn.Tab.TabID;
  dynamic cacheSettings = null; // dynamic if App.Data is dynamic, otherwise use correct type
  dynamic notAppliedSettings = null;
  var isParentSetting = false;
  var appliedByParent = false;
  var isEnabled = false;

  bool found = false;
  bool searchedParent = false;

  // Search for cacheSettings for current page
  cacheSettings = allCacheSettings?.FirstOrDefault(c => c.PageId != null && c.PageId == tab.TabID);

  if (cacheSettings != null && cacheSettings.PageId == currentTabId)
  {
    // If found for current page, but ApplyToPage is false, search parents
    if (cacheSettings.ApplyToPage == false)
    {
      searchedParent = true;
      notAppliedSettings = cacheSettings;
      // Search parent chain for ApplyToChildren == true
      var parentTab = DotNetNuke.Entities.Tabs.TabController.Instance.GetTab(tab.ParentId, currentTab.PortalId, false);
      while (parentTab != null)
      {
        var parentSetting = allCacheSettings?.FirstOrDefault(c => c.PageId != null && c.PageId == parentTab.TabID);
        if (parentSetting != null && parentSetting.ApplyToChildren == true)
        {
          cacheSettings = parentSetting;
          isParentSetting = true;
          found = true;
          break;
        }
        parentTab = DotNetNuke.Entities.Tabs.TabController.Instance.GetTab(parentTab.ParentId, currentTab.PortalId, false);
      }
    }
    else
    {
      // Use current page, ApplyToPage == true
      found = true;
    }
  }
  else
  {
    // No settings for current page, search parent chain for ApplyToChildren == true
    var parentTab = tab;
    while (parentTab != null)
    {
      parentTab = DotNetNuke.Entities.Tabs.TabController.Instance.GetTab(parentTab.ParentId, currentTab.PortalId, false);
      if (parentTab == null) break;
      var parentSetting = allCacheSettings?.FirstOrDefault(c => c.PageId != null && c.PageId == parentTab.TabID);
      if (parentSetting != null && parentSetting.ApplyToChildren == true)
      {
        cacheSettings = parentSetting;
        isParentSetting = true;
        found = true;
        break;
      }
    }
  }

  // Show info if a cache setting was found in the hierarchy
  if (found && cacheSettings != null)
  {

    appliedByParent = isParentSetting ? cacheSettings.ApplyToChildren : false;
    isEnabled = cacheSettings.Get("IsEnabled") != null ? cacheSettings.IsEnabled : App.Settings.IsEnabled;

    <div class="alert alert-success">
      <div>Settings found from PageId: @cacheSettings.PageId</div>
      <div>Current TabId: @currentTabId</div>

      @if (isParentSetting && appliedByParent)
      {
        if (notAppliedSettings != null && searchedParent)
        {
          <div>
            Settings found but are <strong>NOT applied</strong><br />
            Titel: <strong>@notAppliedSettings.Title</strong>
          </div>
        }

        <div>Settings are applied from parent page.</div>
      }

      @if (!isParentSetting && cacheSettings.ApplyToPage)
      {
        <div>Settings are applied to this page.</div>
      }

      <strong>@cacheSettings.Title</strong>
    </div>
  }
  else
  {
    <div class="alert alert-info" @Edit.TagToolbar(Content, toolbar: new[] { "new&color=red?contentType=CacheSettings&prefill:PageId=" + currentTabId })>
      This has no Settings yet. Create one for the current Page: @currentTabId.
    </div>
    return;
  }

  var cacheMaxAge = cacheSettings.Get("MaxAge") != null ? cacheSettings.MaxAge : App.Settings.MaxAge;
  var cacheSMaxAge = cacheSettings.Get("SMaxAge") != null ? cacheSettings.SMaxAge : App.Settings.SMaxAge;
  var cacheTag = Text.Has(cacheSettings.CacheTag) ? cacheSettings.CacheTag : App.Settings.CacheTag;
  var now = DateTime.UtcNow;
  var header = "";

  var toolbar = Edit.TagToolbar(cacheSettings);

  if (isParentSetting && notAppliedSettings == null)
  {
    toolbar = Edit.TagToolbar(cacheSettings, toolbar: new[] { "-edit", "new&color=red?contentType=CacheSettings&prefill:PageId=" + currentTabId });
  }

  if (notAppliedSettings != null)
  {
    toolbar = Edit.TagToolbar(notAppliedSettings);
  }

  if (isEnabled)
  {
    @* HeaderCache.SetPublicCacheHeaders(Response, cacheMaxAge, cacheSMaxAge); *@
    SetPublicCacheHeaders(Response, (int)cacheMaxAge, (int)cacheSMaxAge, cacheTag);
    header = $"public, max-age={cacheMaxAge}, s-maxage={cacheSMaxAge}";
  }
}

@* <div class="accordion" id="app-cdn" @Kit.Toolbar.Default(MyItem)> *@
<div class="accordion" id="app-cdn" @toolbar>
  <div class="accordion-item">
    <h2 class="accordion-header">
      <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#app-cache-settings">
        Caching @(isEnabled ? "enabled ✔️" : "disabled ❌")
      </button>
    </h2>
    <div id="app-cache-settings" class="accordion-collapse collapse show" data-bs-parent="#app-cdn">
      <div class="accordion-body">
        @* @if (MyUser.IsContentAdmin) *@
        @if (Edit.Enabled)
        {
          <h3>Flush Cache</h3>
          <div class="input-group mb-3">
            <button class="btn btn-primary" type="button" id="full-purge">Purge Everything</button>
            <button class="btn btn-outline-primary" type="button" id="custom-purge">Custom Purge</button>
            <input type="text" class="form-control" placeholder="Enter url which should be purged" value="@Link.To()" id="custom-purge-url">
          </div>
        }

        <h3>Stats:</h3>
        <ul>
          <li><b>Cache Control should be:</b> @(isEnabled? header : "❌")</li>
          <li><b>Server-Zeit (UTC):</b> <span id="server-time">@now.ToString("yyyy-MM-dd HH:mm:ss")</span></li>
          <li><b>Browser-Zeit (lokal):</b> <span id="browser-time"></span></li>
          <li><b>CF-Cache-Status (HTML):</b> <span id="cf-status-html">wird geladen...</span></li>
          <li><b>CF-Cache-Status (JS):</b> <span id="cf-status-js">wird geladen...</span></li>
          <li><b>CF-Cache-Status (CSS):</b> <span id="cf-status-css">wird geladen...</span></li>
          <li><b>CF-Cache-Status (Bild):</b> <span id="cf-status-img">wird geladen...</span></li>
        </ul>

        <h3>Tags:</h3>
        <ul>
          <li><b>Cache Tags:</b> @(Text.Has(cacheTag) ? cacheTag : "no tags")</li>
        </ul>
      </div>
    </div>
  </div>
</div>

@* <script src="@App.Folder.Url/dist/main.js"></script> *@
@* <script src="@App.Path/dist/main.js"></script> *@

<script>
  function updateBrowserTime() {
    const now = new Date();
    document.getElementById("browser-time").textContent =
      now.toLocaleString("de-DE", { hour12: false });
  }
  setInterval(updateBrowserTime, 1000);
  updateBrowserTime();

  async function getCacheStatus(url) {
    try {
      const res = await fetch(url, { method: "GET", cache: "reload" });
      const cf = res.headers.get("cf-cache-status") || "nicht vorhanden";
      const cc = res.headers.get("cache-control") || "nicht vorhanden";
      const isPublic = cc.toLowerCase().includes("public");
      return { cf, cc, isPublic };
    } catch {
      return { cf: "Fehler beim Laden", cc: "Fehler beim Laden", isPublic: false };
    }
  }

  function applyStatus(targetId, status) {
    const el = document.getElementById(targetId);
    if (!el) return;

    const colors = {
      HIT: "green",
      MISS: "orange",
      EXPIRED: "orange",
      DYNAMIC: "red",
      BYPASS: "red",
      "Fehler beim Laden": "red",
    };

    el.textContent = status;
    el.style.color = colors[status] || "black";
  }

  async function doTests(debug = false) {
    const targets = [
      { selector: window.location.href, prop: null, id: "cf-status-html" },
      { selector: "script[src]", prop: "src", id: "cf-status-js" },
      { selector: 'link[rel="stylesheet"][href]', prop: "href", id: "cf-status-css" },
      { selector: "img[src]", prop: "src", id: "cf-status-img" },
    ];

    const results = await Promise.all(
      targets.map(async ({ selector, prop }) => {
        if (prop === null) return getCacheStatus(selector);
        const el = document.querySelector(selector);
        return el ? getCacheStatus(el[prop]) : "nicht vorhanden";
      })
    );

    if (debug) {
      alert(
        `Cache Status:\n` +
        `HTML: CF=${results[0].cf}, CC=${results[0].cc}, ${results[0].isPublic ? "✅ public" : "❌ not public"}\n` +
        `JS:   CF=${results[1].cf}, CC=${results[1].cc}, ${results[1].isPublic ? "✅ public" : "❌ not public"}\n` +
        `CSS:  CF=${results[2].cf}, CC=${results[2].cc}, ${results[2].isPublic ? "✅ public" : "❌ not public"}\n` +
        `IMG:  CF=${results[3].cf}, CC=${results[3].cc}, ${results[3].isPublic ? "✅ public" : "❌ not public"}`
      );
    } else {
      for (let i = 0; i < targets.length; i++) {
        const el = document.getElementById(targets[i].id);
        if (!el) continue;

        applyStatus(targets[i].id, results[i].cf);

        const ccNote = results[i].isPublic ? "✅ public" : "❌ not public";
        el.insertAdjacentHTML("afterend", ` <small>(${ccNote})</small>`);
      }
    }
  }

  const debug = window.location.hash === "#debug";
  doTests(debug);
</script>

<script>
  const customPurgeBtn = document.querySelector('#custom-purge');
  if (customPurgeBtn) {
    customPurgeBtn.addEventListener('click', function () {
      const customUrl = document.querySelector('#custom-purge-url').value;
      purgeCache(customUrl);
    });
  }

  const fullPurgeBtn = document.querySelector('#full-purge');
  if (fullPurgeBtn) {
    fullPurgeBtn.addEventListener('click', function () {
      purgeCache();
    });
  }

  function purgeCache(url = '') {
    var sxc = $2sxc(6923);
    var urlParams = {};
    var postParams = {
      flushUrl: url
    };

    sxc.webApi.post('app/auto/api/Cache/Purge', urlParams, postParams)
      .then(data => {
        console.log(data)
      });
  }

</script>

@functions {
  public void SetPublicCacheHeaders(HttpResponseBase Response, int browserCacheSeconds, int cloudflareCacheSeconds, string cacheTags = "")
  {
    Response.Cache.SetCacheability(HttpCacheability.Public);
    var ttlBrowser = TimeSpan.FromSeconds(browserCacheSeconds);
    var ttlCloudflare = TimeSpan.FromSeconds(cloudflareCacheSeconds);
    Response.Cache.SetMaxAge(ttlBrowser);
    Response.Cache.SetProxyMaxAge(ttlCloudflare);

    if (cacheTags != "")
    {
      Response.Headers.Add("Cache-Tag", cacheTags);
    }
  }
}