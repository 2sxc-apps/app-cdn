@* @inherits AppCode.Razor.AppRazor
@using AppCode.Data *@
@* @using AppCode.Helpers *@

@inherits ToSic.Sxc.Dnn.RazorComponent
@using ToSic.Razor.Blade

@using System.Web
@using System
@using DotNetNuke.Entities.Portals

@{
  // Get the current tab
  var currentTab = PortalSettings.Current;

  // Get all cache settings items as a list
  // var allCacheSettings = App.Data.GetAll<CacheSettings>();
  var allCacheSettings = AsList(App.Data["CacheSettings"]);

  var tab = currentTab.ActiveTab;
  var currentTabId = Dnn.Tab.TabID;
  dynamic cacheSettings = null; // dynamic if App.Data is dynamic, otherwise use correct type
  dynamic notAppliedSettings = null;
  var isParentSetting = false;
  var appliedByParent = false;
  var isEnabled = false;

  bool found = false;
  bool searchedParent = false;

  // Search for cacheSettings for current page
  cacheSettings = allCacheSettings?.FirstOrDefault(c => c.PageId != null && c.PageId == tab.TabID);

  if (cacheSettings != null && cacheSettings.PageId == currentTabId)
  {
    // If found for current page, but ApplyToPage is false, search parents
    if (cacheSettings.ApplyToPage == false)
    {
      searchedParent = true;
      notAppliedSettings = cacheSettings;
      // Search parent chain for ApplyToChildren == true
      var parentTab = DotNetNuke.Entities.Tabs.TabController.Instance.GetTab(tab.ParentId, currentTab.PortalId, false);
      while (parentTab != null)
      {
        var parentSetting = allCacheSettings?.FirstOrDefault(c => c.PageId != null && c.PageId == parentTab.TabID);
        if (parentSetting != null && parentSetting.ApplyToChildren == true)
        {
          cacheSettings = parentSetting;
          isParentSetting = true;
          found = true;
          break;
        }
        parentTab = DotNetNuke.Entities.Tabs.TabController.Instance.GetTab(parentTab.ParentId, currentTab.PortalId, false);
      }
    }
    else
    {
      // Use current page, ApplyToPage == true
      found = true;
    }
  }
  else
  {
    // No settings for current page, search parent chain for ApplyToChildren == true
    var parentTab = tab;
    while (parentTab != null)
    {
      parentTab = DotNetNuke.Entities.Tabs.TabController.Instance.GetTab(parentTab.ParentId, currentTab.PortalId, false);
      if (parentTab == null) break;
      var parentSetting = allCacheSettings?.FirstOrDefault(c => c.PageId != null && c.PageId == parentTab.TabID);
      if (parentSetting != null && parentSetting.ApplyToChildren == true)
      {
        cacheSettings = parentSetting;
        isParentSetting = true;
        found = true;
        break;
      }
    }
  }

  if (!found || cacheSettings == null)
  {
    <div class="alert alert-info" @Edit.TagToolbar(Content, toolbar: new[] { "new&color=red?contentType=CacheSettings&prefill:PageId=" + currentTabId })>
      @App.Resources.MsgNoSettings @currentTabId.
    </div>
    return;
  }

  appliedByParent = isParentSetting ? cacheSettings.ApplyToChildren : false;
  isEnabled = cacheSettings.Get("IsEnabled") != null ? cacheSettings.IsEnabled : App.Settings.IsEnabled;

  var cacheMaxAge = cacheSettings.Get("MaxAge") != null ? cacheSettings.MaxAge : App.Settings.MaxAge;
  var cacheSMaxAge = cacheSettings.Get("SMaxAge") != null ? cacheSettings.SMaxAge : App.Settings.SMaxAge;
  var cacheTag = Text.Has(cacheSettings.CacheTag) ? cacheSettings.CacheTag : App.Settings.CacheTag;
  var now = DateTime.UtcNow;
  var header = "";

  var toolbar = Edit.TagToolbar(cacheSettings);

  if (isParentSetting && notAppliedSettings == null)
  {
    toolbar = Edit.TagToolbar(cacheSettings, toolbar: new[] { "-edit", "new&color=red?contentType=CacheSettings&prefill:PageId=" + currentTabId });
  }

  if (notAppliedSettings != null)
  {
    toolbar = Edit.TagToolbar(notAppliedSettings);
  }

  if (isEnabled)
  {
    @* HeaderCache.SetPublicCacheHeaders(Response, cacheMaxAge, cacheSMaxAge); *@
    SetPublicCacheHeaders(Response, (int)cacheMaxAge, (int)cacheSMaxAge, cacheTag);
    header = $"public, max-age={cacheMaxAge}, s-maxage={cacheSMaxAge}";
  }
}

<script>
  async function getCacheStatus(url) {
    try {
      const res = await fetch(url, { method: "GET", cache: "reload" });
      const cf = res.headers.get("cf-cache-status") || "missing";
      const cc = res.headers.get("cache-control") || "missing";
      const isPublic = cc.toLowerCase().includes("public");
      return { cf, cc, isPublic };
    } catch {
      return { cf: "Error loading", cc: "Error loading", isPublic: false };
    }
  }

  function formatCacheStatus(results) {
    const cacheTypes = ["HTML", "JS", "CSS", "IMG"];
    const lines = cacheTypes.map((type, i) => {
      const { cf, cc, isPublic } = results[i] || {};
      return `${type}: CF=${cf}, CC=${cc}, ${isPublic ? "✅ public" : "❌ not public"}`;
    });

    const serverTime = '@now.ToString("yyyy-MM-dd HH:mm:ss")';
    const browserTime = new Date().toLocaleString("de-DE", { hour12: false });

    return (
      `Cache Status: @(isEnabled ? "enabled" : "disabled")\n` +
      `Cache-Control: @header\n` +
      `Cache-Tag: @cacheTag\n` +
      `Server-Zeit: ${serverTime} Browser-Zeit: ${browserTime}\n` +
      lines.join('\n')
    );
  }

  async function showCacheInfo(debug = false) {
    const targets = [
      { selector: window.location.href, prop: null, id: "cf-status-html" },
      { selector: "script[src]", prop: "src", id: "cf-status-js" },
      { selector: 'link[rel="stylesheet"][href]', prop: "href", id: "cf-status-css" },
      { selector: "img[src]", prop: "src", id: "cf-status-img" },
    ];

    const results = await Promise.all(
      targets.map(async ({ selector, prop }) => {
        if (prop === null) return getCacheStatus(selector);
        const el = document.querySelector(selector);
        return el ? getCacheStatus(el[prop]) : { cf: "missing", cc: "missing", isPublic: false };
      })
    );

    const statusText = formatCacheStatus(results);

    if (debug) {
      alert(statusText);
    } else {
      const statsEl = document.querySelector('#app-stats');
      if (statsEl) statsEl.value = statusText;
    }
  }

  const debug = window.location.hash === "#cachedebug";
  if (debug) {
    showCacheInfo(debug);
  }
</script>

@{
  // Get the value of the Cache-Control response header, if available
  var cacheControlHeader = "";
  if (Response.Headers.AllKeys.Contains("Cache-Control"))
  {
    cacheControlHeader = Response.Headers["Cache-Control"];
  }
}
<div>
  <strong>Cache-Control Header:</strong> @cacheControlHeader
</div>

@if (Edit.Enabled)
{
  <div class="accordion" id="app-cdn">
    <div class="accordion-item">
      <h2 class="accordion-header">
        <button class="accordion-button @(App.Settings.OpenSettings ? "" : "collapsed")" type="button" data-bs-toggle="collapse" data-bs-target="#app-cache-settings">
          Caching @(isEnabled? App.Resources.LabelEnabled + " ✔️" : App.Resources.LabelDisabled + " ❌")
        </button>
      </h2>
      <div id="app-cache-settings" class="accordion-collapse @(App.Settings.OpenSettings ? "collapse show" : "collapse")" data-bs-parent="#app-cdn">
        <div class="accordion-body">

          <div class="alert alert-success" @toolbar>

            @if (isParentSetting && appliedByParent)
            {
              if (notAppliedSettings != null && searchedParent)
              {
                <div>
                  @Html.Raw(App.Resources.MsgNotAppliedSettings)
                  @if (Text.Has(notAppliedSettings.Title))
                  {
                    <div>@App.Resources.LabelTitle <strong>@notAppliedSettings.Title</strong></div>
                  }
                </div>
              }

              <div>@App.Resources.MsgAppliedFromParent @cacheSettings.PageId</div>
              <div>@App.Resources.LabelCurrentTabId @currentTabId</div>
            }

            @if (!isParentSetting && cacheSettings.ApplyToPage)
            {
              <div>@App.Resources.MsgAppliedToPage @currentTabId</div>
            }

            @if (Text.Has(cacheSettings.Title))
            {
              <div>@App.Resources.LabelTitle <strong>@cacheSettings.Title</strong></div>
            }

            <div><strong>MaxAge:</strong> @cacheMaxAge <strong>SMaxAge:</strong> @cacheSMaxAge</div>
          </div>

          <h3>Cache</h3>
          <div class="input-group mb-3">
            <button class="btn btn-primary" type="button" id="custom-purge">@App.Resources.FlushUrl</button>
            <input type="text" class="form-control" placeholder="Enter url which should be purged" value="@Link.To()" id="custom-purge-url">
          </div>

          <div class="input-group mb-3">
            <button class="btn btn-outline-primary" type="button" id="tag-purge">@App.Resources.FlushTags</button>
            <input type="text" class="form-control" value="" id="tag-purge-url">
          </div>

          <div class="input-group mb-3">
            <button class="btn btn-outline-primary" type="button" id="full-purge">@App.Resources.FlushAll</button>
          </div>

          @if (PortalSettings.Current.UserInfo.IsSuperUser)
          {
            <h3>@App.Resources.LabelStats</h3>
            <div class="text-danger">@Html.Raw(App.Resources.MsgOpenInAnonymous)</div>
            <textarea class="form-control" id="app-stats" rows="8" readonly></textarea>
          }

          <script>
            showCacheInfo();
          </script>

        </div>
      </div>
    </div>
  </div>
}

<!-- Server-Rendertime: @now.ToString("yyyy-MM-dd HH:mm:ss") -->
<script src="@App.Path/dist/index.js"></script>

@functions {
  public void SetPublicCacheHeaders(HttpResponseBase Response, int browserCacheSeconds, int cloudflareCacheSeconds, string cacheTags = "")
  {
    Response.Cache.SetCacheability(HttpCacheability.Public);
    var ttlBrowser = TimeSpan.FromSeconds(browserCacheSeconds);
    var ttlCloudflare = TimeSpan.FromSeconds(cloudflareCacheSeconds);
    Response.Cache.SetMaxAge(ttlBrowser);
    Response.Cache.SetProxyMaxAge(ttlCloudflare);

    if (cacheTags != "")
    {
      Response.Headers.Add("Cache-Tag", cacheTags);
    }
  }
}