@* @inherits AppCode.Razor.AppRazor
@using AppCode.Data
@using AppCode.Helpers *@

@inherits ToSic.Sxc.Dnn.RazorComponent
@using ToSic.Razor.Blade

@using System.Web
@using System
@using DotNetNuke.Entities.Portals
@using DotNetNuke.Entities.Tabs;

@{
  var currentTabId = Dnn.Tab.TabID;

  // var allCacheSettings = App.Data.GetAll<CacheSettings>();
  var allCacheSettings = AsList(App.Data["CacheSettings"]);

  // First, try to find a setting which references the current page
  var status = new SettingsBundle {
    ForPageId = currentTabId,
    OfPageId = currentTabId,
    Settings = allCacheSettings?.FirstOrDefault(c => c.PageId == currentTabId),
    IgnoredPageSettings = null,
    TriedParents = false
  };

  // We don't have a rule for this page, or it doesn't apply
  // check if a parent page has a rule which applies to children
  if (status.Settings == null || status.Settings.ApplyToPage == false)
  {
    status = FindParentCacheSetting(status, allCacheSettings);
  }
}

@* If no rules found - show an info + button to optionally add a rule *@
@* TODO: @2ro - this looks wrong - it would show for all users? + why not show the stats etc. just because it's disabled ? *@
@if (!status.Found)
{
  <div class="alert alert-info" @Edit.TagToolbar(Content, toolbar: new[] { "new&color=red?contentType=CacheSettings&prefill:PageId=" + currentTabId })>
    @App.Resources.MsgNoSettings @currentTabId.
  </div>
  return;
}

@{
  var isEnabled = status.Settings.Get("IsEnabled") != null
    ? status.Settings.IsEnabled
    : App.Settings.IsEnabled;

  var cacheMaxAge = status.Settings.Get("MaxAge") != null
    ? status.Settings.MaxAge
    : App.Settings.MaxAge;

  var cacheSMaxAge = status.Settings.Get("SMaxAge") != null
    ? status.Settings.SMaxAge
    : App.Settings.SMaxAge;

  var cacheTag = Text.First(status.Settings.CacheTag, App.Settings.CacheTag);

  var timeStamp = DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss");

  var header = "";
  if (isEnabled)
  {
    @* HeaderCache.SetPublicCacheHeaders(Response, cacheMaxAge, cacheSMaxAge); *@
    SetPublicCacheHeaders(Response, (int)cacheMaxAge, (int)cacheSMaxAge, cacheTag);
    header = $"public, max-age={cacheMaxAge}, s-maxage={cacheSMaxAge}";
  }
}

@* Add a hidden timestamp to better debug any issues *@
<!-- Server Timestamp: @timeStamp -->

@* Add scripts etc. to optionally show caching information in anonymous mode, if the correct link is used *@
@* TODO: @2ro - this looks wrong, the JS is "blocking" and there is no turn-on to ensure the code works as expected*@
<script src="@App.Path/dist/index.js"></script>
<script>
    window.initCacheStatus(@isEnabled.ToString().ToLower(), "@header", "@cacheTag", "@timeStamp");
  </script>

@* Show Admin Area to Editors *@
@if (Edit.Enabled)
{
  // Determine best toolbar
  var toolbar = Edit.TagToolbar(status.Settings);

  if (status.IsOfParent && status.IgnoredPageSettings == null)
  {
    toolbar = Edit.TagToolbar(status.Settings, toolbar: new[] { "-edit", "new&color=red?contentType=CacheSettings&prefill:PageId=" + currentTabId });
  }

  if (status.IgnoredPageSettings != null)
  {
    toolbar = Edit.TagToolbar(status.IgnoredPageSettings);
  }

  @* Accordion with everything *@
  <div class="accordion" id="app-cdn">
    <div class="accordion-item">
      @* Accordion Header with status information *@
      <h2 class="accordion-header">
        <button class="accordion-button @(App.Settings.OpenSettings ? "" : "collapsed")" type="button" data-bs-toggle="collapse" data-bs-target="#app-cache-settings">
          Output Caching @(isEnabled ? App.Resources.LabelEnabled + " ✔️" : App.Resources.LabelDisabled + " ❌")
        </button>
      </h2>

      @* Accordion Body with settings and stats; should be collapsed in production (see App setting for that) *@
      <div id="app-cache-settings" class="accordion-collapse collapse @(App.Settings.OpenSettings ? "show" : "")" data-bs-parent="#app-cdn">
        <div class="accordion-body">

          @* Green box showing which settings are being used *@
          <div class="alert alert-success" @toolbar>

            @if (status.IsOfParent && status.Settings.ApplyToChildren)
            {
              if (status.IgnoredPageSettings != null && status.TriedParents)
              {
                <div>
                  @Html.Raw(App.Resources.MsgNotAppliedSettings)
                  <div>@App.Resources.LabelTitle <strong>@Text.First(status.IgnoredPageSettings.Title, "-")</strong></div>
                </div>
              }

              <div>@App.Resources.MsgAppliedFromParent @status.Settings.PageId</div>
              <div>@App.Resources.LabelCurrentTabId @currentTabId</div>
            }

            @if (!status.IsOfParent && status.Settings.ApplyToPage)
            {
              <div>@App.Resources.MsgAppliedToPage @currentTabId</div>
            }

            <div>@App.Resources.LabelTitle <strong>@Text.First(status.Settings.Title, "-")</strong></div>
            <div>
              @App.Resources.LabelSettings
              <strong>MaxAge:</strong> <code>@cacheMaxAge</code>;
              <strong>SMaxAge:</strong> <code>@cacheSMaxAge</code>;
              <strong>Cache-Tag:</strong> <code>@Text.First(cacheTag, "-")</code>
            </div>

            @* Info to see the final stats in anonymous mode is for everybody *@
            <div class="text-danger">@Html.Raw(App.Resources.MsgOpenInAnonymous)</div>

          </div>

          <h3>@App.Resources.FlushTitle</h3>
          <div class="input-group mb-3">
            <button class="btn btn-primary" type="button" id="custom-purge">@App.Resources.FlushUrl</button>
            <input type="text" class="form-control" placeholder="Enter url which should be purged" value="@Link.To()" id="custom-purge-url">
          </div>

          <div class="input-group mb-3">
            <button class="btn btn-outline-primary" type="button" id="tag-purge">@App.Resources.FlushTags</button>
            <input type="text" class="form-control" value="" id="tag-purge-url">
          </div>

          <div class="input-group mb-3">
            <button class="btn btn-outline-primary" type="button" id="full-purge">@App.Resources.FlushAll</button>
          </div>

          @* Only show statistics to super users, and others would be confused *@
          @if (PortalSettings.Current.UserInfo.IsSuperUser)
          {
            <h3>@App.Resources.StatisticsTitle</h3>
            @Html.Raw(App.Resources.StatisticsIntro)
            <textarea class="form-control" id="app-stats" rows="8" readonly></textarea>
          }
        </div>
      </div>
    </div>
  </div>
}

@functions {
  public void SetPublicCacheHeaders(HttpResponseBase Response, int browserCacheSeconds, int cloudflareCacheSeconds, string cacheTags = "")
  {
    Response.Cache.SetCacheability(HttpCacheability.Public);
    var ttlBrowser = TimeSpan.FromSeconds(browserCacheSeconds);
    var ttlCloudflare = TimeSpan.FromSeconds(cloudflareCacheSeconds);
    Response.Cache.SetMaxAge(ttlBrowser);
    Response.Cache.SetProxyMaxAge(ttlCloudflare);

    if (cacheTags != "")
    {
      Response.Headers.Add("Cache-Tag", cacheTags);
    }
  }

  private SettingsBundle FindParentCacheSetting(SettingsBundle original, IEnumerable<dynamic> allSettings)
  {
    var portalId = PortalSettings.Current.PortalId;
    var parentTab = PortalSettings.Current.ActiveTab;
    while (parentTab != null)
    {
      // Check if we have a parent-page
      var parentId = parentTab.ParentId;
      parentTab = TabController.Instance.GetTab(parentId, portalId, false);
      if (parentTab == null)
        break;

      // See if the parent page has a setting which applies to children
      var parentSetting = allSettings?.FirstOrDefault(c => c.PageId == parentId);
      if (parentSetting?.ApplyToChildren == true)
        return new SettingsBundle(original) { OfPageId = parentId, Settings = parentSetting };
    }
    return new SettingsBundle(original) { OfPageId = 0, Settings = null };
  }

  private class SettingsBundle
  {
    public SettingsBundle() { }

    public SettingsBundle(SettingsBundle original)
    {
      ForPageId = original.ForPageId;
      IgnoredPageSettings = original.Settings;
      TriedParents = true;
    }

    public int ForPageId;
    public bool IsOfParent { get { return ForPageId != OfPageId; } }
    public int OfPageId;
    public bool Found { get { return Settings != null; } }
    public dynamic Settings;
    public dynamic IgnoredPageSettings;
    public bool TriedParents;
  }
}